---
emoji: 🧢
title: 자바 병렬프로그래밍 2장 정ㅣ
date: '2023-03-07 17:30:00'
author: Roach
tags: java jvm
categories: java
---
스레드 간 공유될 수 있는 변수가 **수정 가능(mutable)하다는 것**은 여러 스레드가 특정 변수에 동시에 접근하여 수정하는 상황이 발생할 수도 있음을 뜻 한다. 그래서 대부분의 현대적 언어들은 수정가능한 변수(mutable) 을 키워드로 표시할 수 있게 끔 해준다. 이렇게 하면, 스레드 문제 발생시 살펴봐야 할 변수도 적어질 뿐더러, 사전에 동시 접근 수정으로 인한 문제들을 방지할 수 있게 된다. 만약 이러한 기능이 없다면 캡슐화를 하고, 최대한 내부 필드에 대한 접근을 최소화 하여 살펴봐야 하는 변수들의 모수를 줄이는 방법이 있다.
## 경쟁 조건(Race Condition)
경쟁 조건이란, 위에서 말한 것 같이 **“여러 스레드가 동시에 하나의 값에 접근하여 값을 수정하는 경우 우리의 예상과는 다른 결과가 나올 수 있는 상황”**을 뜻한다. 즉, 타이밍에 따라 이상한 값을 얻거나 정상적인 값을 얻을 수도 있는 상황을 뜻한다.

```java
@NotThreadSafe
public class LazeInitRace {
	private ExpensiveObject instance = null;
	
	public ExpensiveObject getInstance() {
		if (instance == null) instance = new ExpensiveObject();
		return instance;
	}
}
```

위 코드는 **싱글톤(Singleton)** 객체를 만드는 방법 중 하나이다. 위 코드에는 어떤 문제가 존재할까? 위 코드에 스레드 두개가 동시에 접근한다고 해보자, A 랑 B 가 동시에 getInstance() 메소드를 호출했더니, 둘다 null 임을 확인하고 객체를 만들었다. 우리는 싱글톤으로 운영되길 원했지만 예상되는 결과는 그렇지 않음을 확인할 수 있다. 하지만, A 와 B 가 만약 동시에 접근하지 않았다면 정상적으로 싱글톤(SingleTon) 으로 운영 됐을 것 이다. 즉, 위 코드는 **경쟁 조건(Race Condition)** 상황 을 유발시키는 코드이다.
암묵적인 락(Intrinsic lock)
자바에는 특정 연산을 스레드 안전하게 보호하기 위해 synchronized 라는 키워드가 존재한다.
```java 
synchronized (lock) { // code that want to protect by thread }
```
위와 같이 **코드 블록과 lock 객체**가 존재하며, 보호 받고 싶은 부분에 해당하는 연산을 블록안으로 넣어주면 쉽게 사용가능하다. Lock 을 걸게 되면 여러 스레드가 순차적으로 해당 연산에 접근하게 된다. 자바의 Vector 클래스 처럼 락을 활용하는 일반적인 방법은 모든 변경 가능한 변수를 객체안에 캡슐화하고, 변수에 접근하는 **모든 통로를 동기화** 함으로써 스레드로 부터 보호하는 방법이다.
## 성능
왜 그렇다면 모든 메소드에 synchronized 를 걸지 않을까? 위와 같은 방법으로 하면 대부분 안전하게 짤 수 있겠지만, 우리는 애초에 동시에 무언가를 처리해서 작업의 효율성을 증대하기 위해 멀티-스레드 프로그래밍을 하는 것이지 순차적으로 실행하기 위해 멀티-스레드 프로그래밍을 사용하지 않았기 때문이다. 모든 것을 동기화해서 사용하게 되면 멀티-스레드로 동시에 접근할때보다 현저하게 느려진다. 따라서, 동기화 해야하는 작은 부분을 찾아야 한다.
## 가시성(Visibility)
가시성이란 여러개의 스레드가 공유된 변수에 접근할때 **“반드시 해당 변수가 제일 최신의 데이터"** 를 가져옴을 보장 할 수 없다” 는 것이다. 이 이유에는 여러가지가 있을 수 있다. 레지스터 캐시나 JVM 의 ***“\*재배치(Reordering)”*** 등등 의 원인이 있다.  따라서, 멀티-스레드 프로그래밍에서는 개발자가 스레드 간의 데이터가 공유될수 있음을 명시적으로 표기해주어야 한다.
Java 에는 volatile 이라는 키워드가 존재하는데 이를 통해 우리는 이 변수는 **“스레드 간에 공유되며, Reordering 되거나 레지스터에 캐시가 되선 안되"** 라는 것을 컴파일러에게 말해줄 수 있다. 다만 가시*성을 확보하는 것이지 절대로 synchronized 와 같은 역할을 하지 않는다. 이점을 주의해야 한다.
정리하자면 volatile 키워드를 이용하는 상황은 아래와 같다.
- **단일 연산으로 해당 변수를 바꿀때 가시성을 올리고 싶을때**

## 정리
기존에 알고 있었던 개념이였지만, 오랜만에 책을 읽으면서 생각을 정리하는 과정이 재밌었다. 최근에 코틀린 혹은 함수형 프로그래밍을 공부하면서 오히려 캡슐화를 잘 지키지 못할꺼면 val 로 불변(Immutable) 하게 변수를 유지하는 방법이 괜찮을 수도 있겠다 라는 생각도 많이 했는데, 확실히 멀티-스레드 프로그래밍을 공부하다보니 이런점에 대한 생각도 해볼수 있어 좋은것 같다.

—-
**\*재배치(Reordering)**: JVM 에서는 단일 스레드에서는 정상적인 결과를 수행하나, 여러 스레드에서는 정상적으로 작동하지 않는 코드를 만들어 내기도 한다.

